=== Spring Cloud Contract Verifier Messaging

Spring Cloud Contract Verifier allows you to verify your application that uses messaging as means of communication.
All of our integrations are working with Spring but you can also create one yourself and use it.

==== Integrations

You can use one of the three integration configurations:

- Apache Camel
- Spring Integration
- Spring Cloud Stream

You have to provide as a dependency one of the Spring Cloud Contract Verifier Messaging modules. Example for Gradle:

[source,groovy,indent=0]
----
// for Apache Camel
testCompile "org.springframework.cloud:spring-cloud-contract-verifier-camel"
// for Spring Integration
testCompile "org.springframework.cloud:spring-cloud-contract-verifier-integration"
// for Spring Cloud Stream
testCompile "org.springframework.cloud:spring-cloud-contract-verifier-stream"
----

If you're using Spring Boot, the test configurations will be added automatically.

==== Manual Integration Testing

The `spring-cloud-contract-verifier-messaging-core` module contains `ContractVerifierMessageExchange`,
class that allows you to build, send and receive messages

In the a test you can inject a `ContractVerifierMessageExchange` to send and receive messages that follow the contract.

You have to provide as a dependency the messaging module that matches your provider. Example for Gradle and Spring Integration:

[source,groovy,indent=0]
----
testCompile "org.springframework.cloud:spring-cloud-contract-verifier-integration"
----

and then add `@AutoConfigureMessageVerifier` to your test, e.g.

[source,java,indent=0]
----
@RunWith(SpringTestRunner.class)
@SpringBootTest
@AutoConfigureMessageVerifier
public static class MessagingContractTests {

  @Autowired
  private MessageVerifier verifier;
  ...
}
----

NOTE: If your tests require stubs as well, then
`@AutoConfigureStubRunner` includes the messaging configuration, so
you only need the one annotation.

==== Publisher side test generation

Having the `input` or `outputMessage` sections in your DSL will result in creation of tests on the publisher's side. By default
JUnit tests will be created, however there is also a possibility to create Spock tests.

There are 3 main scenarios that we should take into consideration:

- Scenario 1: there is no input message that produces an output one. The output message is triggered by a component
inside the application (e.g. scheduler)
- Scenario 2: the input message triggers an output message
- Scenario 3: the input message is consumed and there is no output message

===== Scenario 1 (no input message)

For the given contract:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_method_dsl]
----

The following JUnit test will be created:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_method_junit_test]
----

And the following Spock test would be created:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_method_test]
----

===== Scenario 2 (output triggered by input)

For the given contract:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_message_dsl]
----

The following JUnit test will be created:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_message_junit]
----

And the following Spock test would be created:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_message_spock]
----

===== Scenario 3 (no output message)

For the given contract:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_no_output_dsl]
----

The following JUnit test will be created:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_no_output_junit]
----

And the following Spock test would be created:

[source,groovy]
----
include::{verifier_core_path}/src/test/groovy/org/springframework/cloud/contract/verifier/builder/MessagingMethodBodyBuilderSpec.groovy[tags=trigger_no_output_spock]
----

==== Consumer Stub Side generation

Unlike the HTTP part - in Messaging we need to publish the Groovy DSL inside the JAR with a stub. Then it's parsed on the consumer side
and proper stubbed routes are created.

For more information please consult the Stub Runner Messaging sections.

===== Gradle Setup

Example of Spring Cloud Contract Verifier Gradle setup:

[source,groovy,indent=0]
----
include::{plugins_path}/spring-cloud-contract-gradle-plugin/src/test/resources/functionalTest/scenarioProject/build.gradle[tags=jar_setup,indent=0]
----

===== Maven Setup

Example of Maven can be found in the https://github.com/spring-cloud/spring-cloud-contract/[Spring Cloud Contract Verifier README]
